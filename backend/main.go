package main

import (
	"database/sql"
	"errors"
	"fmt"
	"log"
	"time"

	jwt "github.com/appleboy/gin-jwt/v2"

	"golang.org/x/crypto/bcrypt"

	_ "github.com/StudioAquatan/LabLibrary/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
	"github.com/spf13/viper"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

// @title LabLibrary API
// @version 1.0
// @description LabLibrary backend API reference.
// @termsOfService http://swagger.io/terms/

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

const API_V1 = "/api/v1"

var db *sqlx.DB

type User struct {
	Name          string
	Password      string
	MailAddr      string
	ThumbnailPath string
	Rank          int
}

type ReqLogin struct {
	AccountName string
	Password    string
}

var identityKey = "id"

func main() {
	_ = viper.BindEnv("DB_USER")
	_ = viper.BindEnv("DB_PASSWORD")
	_ = viper.BindEnv("DB_NAME")

	r := gin.New()
	r.Use(gin.Logger())

	// db
	dataSrcName := fmt.Sprintf("%s:%s@/%s", viper.Get("DB_USER"), viper.Get("DB_PASSWORD"), viper.Get("DB_NAME"))
	db, err := sqlx.Open("mysql", dataSrcName)
	if err != nil {
		log.Fatalf("[ERROR] sqlx.open: %s", err)
	}
	err = db.Ping()
	if err != nil {
		log.Fatalf("[ERROR] db.Ping: %s", err)
	}
	defer db.Close()

	// the jwt middleware
	authMiddleware, err := jwt.New(&jwt.GinJWTMiddleware{
		Realm: "LabLibrary",
		//TODO key周りちゃんと設定する
		Key:         []byte("secret key"),
		Timeout:     time.Hour,
		MaxRefresh:  time.Hour,
		IdentityKey: identityKey,
		PayloadFunc: func(data interface{}) jwt.MapClaims {
			if v, ok := data.(*User); ok {
				return jwt.MapClaims{
					identityKey: v.Name,
				}
			}
			return jwt.MapClaims{}
		},
		IdentityHandler: func(c *gin.Context) interface{} {
			claims := jwt.ExtractClaims(c)
			return &User{
				Name: claims[identityKey].(string),
			}
		},
		Authenticator: Login,
		//Authorizator: Authorize,
		Unauthorized: func(c *gin.Context, code int, message string) {
			c.JSON(code, gin.H{
				"code":    code,
				"message": message,
			})
		},
		TokenLookup:   "header: Authorization, query: token, cookie: jwt",
		TokenHeadName: "Bearer",
		TimeFunc:      time.Now,
	})
	if err != nil {
		log.Fatal("JWT Error:" + err.Error())
	}

	errInit := authMiddleware.MiddlewareInit()
	if errInit != nil {
		log.Fatalf("authMiddleware.MiddlewareInit() Error: %s", errInit.Error())
	}

	// handlers
	url := ginSwagger.URL("http://localhost:8080/swagger/doc.json")
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, url))
	r.GET("/", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "hello",
		})
	})

	v1 := r.Group(API_V1)
	v1.POST("/login", authMiddleware.LoginHandler)
	v1.POST("/register", UserRegister)

	// run server
	r.Run()
}

func Login(c *gin.Context) (interface{}, error) {
	var req ReqLogin

	err := c.ShouldBind(&req)
	if err != nil {
		log.Printf("[ERROR] login bind: %s", err)
		return "", jwt.ErrMissingLoginValues
	}

	u := User{}
	err = db.Get(&u, "SELECT * FROM users WHERE account_name = ?", req.AccountName)
	if err == sql.ErrNoRows {
		return nil, jwt.ErrFailedAuthentication
	} else if err != nil {
		log.Printf("[ERROR] Login get user: %s", err)
		return nil, errors.New("something wrong with login")
	}

	err = bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(req.Password))
	if err == bcrypt.ErrMismatchedHashAndPassword {
		return nil, jwt.ErrFailedAuthentication
	} else if err != nil {
		log.Printf("[ERROR] Comparing password: %s", err)
		return nil, errors.New("something wrong with login")
	}

	return u, nil
}

//func Authorize(data interface{}, c *gin.Context) bool {}

func UserRegister(c *gin.Context) {

}
